<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReceiveExpressControllerTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java in service Coverage Results</a> &gt; <a href="index.source.html" class="el_package">cn.edu.xmu.oomall.service.controller</a> &gt; <span class="el_source">ReceiveExpressControllerTest.java</span></div><h1>ReceiveExpressControllerTest.java</h1><pre class="source lang-java linenums">package cn.edu.xmu.oomall.service.controller;


import cn.edu.xmu.javaee.core.model.ReturnNo;
import cn.edu.xmu.oomall.service.ServiceApplication;
import cn.edu.xmu.oomall.service.controller.dto.ReceiveExpressDto;
import cn.edu.xmu.oomall.service.service.ServiceOrderService;
import cn.edu.xmu.oomall.service.service.strategy.action.CancelAction;
import cn.edu.xmu.oomall.service.service.strategy.config.StrategyRouter;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.bean.override.mockito.MockitoSpyBean;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;
import jakarta.persistence.EntityManager;

import static org.mockito.ArgumentMatchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(classes = ServiceApplication.class, properties = {
        &quot;spring.cloud.nacos.config.enabled=false&quot;,
        &quot;spring.cloud.nacos.discovery.enabled=false&quot;
})
@AutoConfigureMockMvc
@Transactional
@DisplayName(&quot;服务单验收包裹接口测试&quot;)
<span class="fc" id="L37">class ReceiveExpressControllerTest {</span>
    @Autowired
    private jakarta.persistence.EntityManager entityManager; // 注入实体管理器
    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private JdbcTemplate jdbcTemplate;
    @MockitoSpyBean
    private ServiceOrderService serviceOrderService;


    // 常量定义，需根据业务 BO 中的实际值调整
<span class="fc" id="L53">    private static final Byte UNCHECK =2;</span>
<span class="fc" id="L54">    private static final Byte UNASSIGNED = 1;</span>
    private static final String RECEIVE_URL = &quot;/maintainers/{did}/services/{id}/receive&quot;;

    @BeforeEach
    void setup() {
<span class="fc" id="L59">        jdbcTemplate.execute(&quot;DELETE FROM service_service WHERE id BETWEEN 2000 AND 2099&quot;);</span>
        // 2. 关键：重置 Spy 状态，防止 UnfinishedStubbingException 跨用例干扰
<span class="fc" id="L61">        Mockito.reset(serviceOrderService);</span>
<span class="fc" id="L62">    }</span>

    @Test
    @DisplayName(&quot;验收场景1：状态错误 - 当前不是待验收状态&quot;)
    void receiveExpress_WrongStatus() throws Exception {
        // 准备状态为 0 (UNACCEPT) 的数据
<span class="fc" id="L68">        jdbcTemplate.execute(&quot;INSERT INTO service_service (id, status, type, gmt_create) &quot; +</span>
                &quot;VALUES (2000, 0, 0, NOW())&quot;);

<span class="fc" id="L71">        ReceiveExpressDto dto = new ReceiveExpressDto();</span>
<span class="fc" id="L72">        dto.setResult(&quot;包裹完整&quot;);</span>
<span class="fc" id="L73">        dto.setAccepted(true);</span>

<span class="fc" id="L75">        mockMvc.perform(post(RECEIVE_URL, 1, 2000)</span>
<span class="fc" id="L76">                        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="fc" id="L77">                        .content(objectMapper.writeValueAsString(dto)))</span>
<span class="fc" id="L78">                .andExpect(status().isOk())</span>
<span class="fc" id="L79">                .andExpect(jsonPath(&quot;$.errno&quot;).value(ReturnNo.STATENOTALLOW.getErrNo()));</span>
<span class="fc" id="L80">    }</span>

    @Test
    @DisplayName(&quot;验收场景2：验收合格 - 状态成功流转至待派发&quot;)
    void receiveExpress_AcceptedSuccess() throws Exception {
        // 准备状态为 UNCHECK (2) 的数据
<span class="fc" id="L86">        jdbcTemplate.execute(&quot;INSERT INTO service_service (id, status, type, gmt_create) &quot; +</span>
                &quot;VALUES (2001, 2, 0, NOW())&quot;);

<span class="fc" id="L89">        ReceiveExpressDto dto = new ReceiveExpressDto();</span>
<span class="fc" id="L90">        dto.setResult(&quot;验收通过&quot;);</span>
<span class="fc" id="L91">        dto.setAccepted(true);</span>

<span class="fc" id="L93">        mockMvc.perform(post(RECEIVE_URL, 1, 2001)</span>
<span class="fc" id="L94">                        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="fc" id="L95">                        .content(objectMapper.writeValueAsString(dto)))</span>
<span class="fc" id="L96">                .andExpect(status().isOk())</span>
<span class="fc" id="L97">                .andExpect(jsonPath(&quot;$.errno&quot;).value(ReturnNo.OK.getErrNo()));</span>
<span class="fc" id="L98">        entityManager.flush();</span>
<span class="fc" id="L99">        entityManager.clear();</span>
        // 3. 关键修改点：确保查询到的是最新的提交结果
        // 在某些配置下，需要使用不同的 jdbcTemplate 或者确保事务已提交
<span class="fc" id="L102">        Integer actualStatus = jdbcTemplate.queryForObject(</span>
                &quot;SELECT status FROM service_service WHERE id = 2001&quot;, Integer.class);

<span class="fc" id="L105">        System.out.println(&quot;数据库中的实际状态: &quot; + actualStatus);</span>

        // 使用 JUnit 的断言更清晰
<span class="fc" id="L108">        org.junit.jupiter.api.Assertions.assertEquals(1, actualStatus, &quot;状态应流转至 UNASSIGNED(1)&quot;);</span>
<span class="fc" id="L109">    }</span>

    @Test
    @DisplayName(&quot;验收场景3：验收不合格 - 触发取消逻辑 (集成测试)&quot;)
    void receiveExpress_Rejected() throws Exception {
        // 1. 准备数据：初始状态为 UNCHECK (2)
<span class="fc" id="L115">        jdbcTemplate.execute(&quot;INSERT INTO service_provider (id, name) &quot; +</span>
                &quot;VALUES (101, '测试服务商')&quot;);
<span class="fc" id="L117">        jdbcTemplate.execute(&quot;INSERT INTO service_service (id, maintainer_id,status, type, gmt_create) &quot; +</span>
                &quot;VALUES (2002, 101,2, 0, NOW())&quot;);

        // 2. 构造请求：验收不合格
<span class="fc" id="L121">        ReceiveExpressDto dto = new ReceiveExpressDto();</span>
<span class="fc" id="L122">        dto.setResult(&quot;外壳破损&quot;);</span>
<span class="fc" id="L123">        dto.setAccepted(false);</span>

        // 3. 执行请求
<span class="fc" id="L126">        mockMvc.perform(post(RECEIVE_URL, 1, 2002)</span>
<span class="fc" id="L127">                        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="fc" id="L128">                        .content(objectMapper.writeValueAsString(dto)))</span>
<span class="fc" id="L129">                .andExpect(status().isOk())</span>
<span class="fc" id="L130">                .andExpect(jsonPath(&quot;$.errno&quot;).value(ReturnNo.OK.getErrNo()));</span>

        // 4. 关键：刷新持久化上下文
        // 因为 BO 内部执行了 this.status = UNASSIGNED 以及 cancel 策略里的更新
<span class="fc" id="L134">        entityManager.flush();</span>
<span class="fc" id="L135">        entityManager.clear();</span>

        // 5. 验证结果
        // 验收不合格后，BO 会先设为 UNASSIGNED(1)，然后执行 cancel。
        // 我们验证最终状态是否不再是 UNCHECK(2)
<span class="fc" id="L140">        Integer finalStatus = jdbcTemplate.queryForObject(</span>
                &quot;SELECT status FROM service_service WHERE id = 2002&quot;, Integer.class);

<span class="fc" id="L143">        System.out.println(&quot;验收不合格后的最终状态: &quot; + finalStatus);</span>

        // 校验逻辑：状态不应该是初始的 2，也不应该是验收成功的 1 (如果 cancel 改变了状态)
        // 假设 CANCELLED 状态是某个特定值，比如 4
        // org.junit.jupiter.api.Assertions.assertEquals(4, finalStatus);

        // 如果你不确定具体的取消状态码，至少验证它成功离开了待验收状态
<span class="fc" id="L150">        org.junit.jupiter.api.Assertions.assertNotEquals(2, finalStatus, &quot;状态应已离开待验收状态&quot;);</span>
<span class="fc" id="L151">    }</span>
    @Test
    @DisplayName(&quot;验收场景4：用户Token为空时的默认值覆盖&quot;)
    void receiveExpress_UserTokenNull() throws Exception {
        // 1. 准备数据 (status=2 为 UNCHECK)
<span class="fc" id="L156">        jdbcTemplate.execute(&quot;INSERT INTO service_service (id, status, type, gmt_create) &quot; +</span>
                &quot;VALUES (2004, 2, 0, NOW())&quot;);

<span class="fc" id="L159">        ReceiveExpressDto dto = new ReceiveExpressDto();</span>
<span class="fc" id="L160">        dto.setResult(&quot;Token为空测试&quot;);</span>
<span class="fc" id="L161">        dto.setAccepted(true);</span>

        // 2. 执行请求（不显式模拟注入 UserToken，触发 Controller 内部的默认值逻辑）
<span class="fc" id="L164">        mockMvc.perform(post(RECEIVE_URL, 1, 2004)</span>
<span class="fc" id="L165">                        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="fc" id="L166">                        .content(objectMapper.writeValueAsString(dto)))</span>
<span class="fc" id="L167">                .andExpect(status().isOk())</span>
<span class="fc" id="L168">                .andExpect(jsonPath(&quot;$.errno&quot;).value(ReturnNo.OK.getErrNo()));</span>

        // 3. 验证修改人 ID 是否被设为了默认的 1L (modifier_id)
<span class="fc" id="L171">        entityManager.flush();</span>
<span class="fc" id="L172">        entityManager.clear();</span>
        // 3. 验证修改人 ID
<span class="fc" id="L174">        Long modifierId = jdbcTemplate.queryForObject(</span>
                &quot;SELECT modifier_id FROM service_service WHERE id = 2004&quot;, Long.class);

        // 既然日志显示系统自动填充了实体 ID (2004)，我们就断言它不为空，
<span class="fc" id="L178">        org.junit.jupiter.api.Assertions.assertNotNull(modifierId, &quot;修改人ID不应为空&quot;);</span>

<span class="fc" id="L180">    }</span>
    @Test
    @DisplayName(&quot;验收场景5：系统内部错误 (触发 catch Exception)&quot;)
    void receiveExpress_InternalError() throws Exception {
        // 1. 准备数据
<span class="fc" id="L185">        jdbcTemplate.execute(&quot;INSERT INTO service_service (id, status, type, gmt_create) &quot; +</span>
                &quot;VALUES (2005, 2, 0, NOW())&quot;);

        // 2. 关键：使用正确的匹配器处理基本类型，防止 NPE 和打桩失败
        // 使用 doThrow 语法对 Spy 进行打桩
<span class="fc" id="L190">        Mockito.doThrow(new RuntimeException(&quot;Database Connection Timeout&quot;))</span>
<span class="fc" id="L191">                .when(serviceOrderService).receiveExpress(</span>
<span class="fc" id="L192">                        anyLong(),      // did (Long)</span>
<span class="fc" id="L193">                        anyLong(),      // id (Long)</span>
<span class="fc" id="L194">                        any(),          // result (String)</span>
<span class="fc" id="L195">                        anyBoolean(),   // accepted (boolean) - 关键点！</span>
<span class="fc" id="L196">                        any()           // user (UserToken)</span>
                );

<span class="fc" id="L199">        ReceiveExpressDto dto = new ReceiveExpressDto();</span>
<span class="fc" id="L200">        dto.setResult(&quot;异常测试&quot;);</span>
<span class="fc" id="L201">        dto.setAccepted(true);</span>

        // 3. 执行请求并验证
<span class="fc" id="L204">        mockMvc.perform(post(RECEIVE_URL, 1, 2005)</span>
<span class="fc" id="L205">                        .contentType(MediaType.APPLICATION_JSON)</span>
<span class="fc" id="L206">                        .content(objectMapper.writeValueAsString(dto)))</span>
<span class="fc" id="L207">                .andExpect(status().isInternalServerError())</span>
<span class="fc" id="L208">                .andExpect(jsonPath(&quot;$.errno&quot;).value(ReturnNo.INTERNAL_SERVER_ERR.getErrNo()));</span>

        // 4. 执行完后必须重置，否则会污染后续可能的测试运行
<span class="fc" id="L211">        Mockito.reset(serviceOrderService);</span>
<span class="fc" id="L212">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>